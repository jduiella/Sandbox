{"version":3,"file":"chunks/DeployManager.js","mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAC0B;AACG;AACmC;AACzD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY,8EAAoB,CAAC,yCAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wFAA8B;AACnD;AACA;AACA;AACA,mBAAmB,yCAAY;AAC/B,yBAAyB,sFAA4B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8CAAK;AAC7B;AACA;AACA,4BAA4B,+EAAqB,CAAC,0CAAa;AAC/D,yBAAyB,sFAA4B;AACrD;AACA;AACA,kCAAkC,6EAAmB;AACrD;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6BAA6B,qFAA2B;AACxD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClEA;AACA;AACiC;AACJ;AACM;AACS;AACD;AAC3C;AACmC;AACP;AACgI;AAC1G;AACE;AACwB;AACN;AAC5B;AACmD;AAC7F;AACA;AACA;AACO;AACP;AACA;AACA,sCAAsC,2EAAiB;AACvD;AACA;AACA;AACA;AACA;AACA,0CAA0C,gFAAsB;AAChE;AACA;AACA;AACA;AACA;AACA,oCAAoC,uEAAa,CAAC,sCAAS;AAC3D,mEAAmE,gFAAsB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA,yEAAyE;AACzE;AACA,+CAA+C;AAC/C;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sEAAY;AAC5B;AACA;AACA;AACA,8CAA8C,sCAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2CAAc;AAC1D,mCAAmC,yCAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,yCAAyC,4CAAyB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sBAAsB,uEAAa,oBAAoB,aAAa,OAAO,eAAe;AAC1F;AACA;AACA;AACA,qEAAqE,mBAAmB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6EAAmB;AAChC,wDAAwD,6BAA6B,IAAI,2BAA2B;AACpH;AACA,6BAA6B,0CAAa;AAC1C,2CAA2C,sCAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6EAAmB;AAChC,wDAAwD,6BAA6B,IAAI,2BAA2B;AACpH;AACA,6BAA6B,0CAAa;AAC1C,eAAe,yEAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,gFAAsB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oDAAsB;AACrD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yCAAY;AACnD;AACA;AACA;AACA;AACA,4CAA4C,sCAAS;AACrD;AACA,oBAAoB,iFAAuB,CAAC,yCAAY;AACxD,oBAAoB,6EAAmB;AACvC;AACA;AACA,+CAA+C,qFAA2B;AAC1E,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iCAAiC,6CAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8EAAoB;AAChC;AACA;AACA,uCAAuC,qFAA2B;AAClE;AACA,wCAAwC,0CAAa;AACrD;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,kCAAkC,sFAA4B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2EAAiB;AAC9B;AACA;AACA,8BAA8B,yCAAY;AAC1C,QAAQ,iFAAuB;AAC/B;AACA,mCAAmC,0CAAa;AAChD;AACA;AACA;AACA;AACA,gBAAgB,+FAAqC;AACrD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,mFAAyB;AACzC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6FAAmC;AACnD;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,2FAAiC;AACjD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sCAAS;AAChD;AACA,0BAA0B,0CAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAa;AACrB,+BAA+B,+EAAqB;AACpD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sCAAS;AAC3C,qCAAqC,sCAAS;AAC9C,kBAAkB,sDAAY;AAC9B,4CAA4C,yDAAa;AACzD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gFAAsB;AACxD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,wBAAwB,uDAAW;AACnC;AACA;AACA,+CAA+C,aAAa;AAC5D;AACA;AACA;AACA;AACA,QAAQ,sEAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6EAAmB;AAC/B,+BAA+B,uEAAiB,CAAC,GAAG,+EAAyB,CAAC;AAC9E,iCAAiC,sCAAS;AAC1C,uCAAuC,qFAA2B;AAClE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uEAAa;AAC3C;AACA;AACA;AACA;AACA;AACA,qCAAqC,yCAAY;AACjD,YAAY,8EAAoB;AAChC;AACA;AACA,uCAAuC,qFAA2B;AAClE,aAAa;AACb;AACA,cAAc,+EAAiC;AAC/C;AACA;AACA;AACA;AACA;AACA,iCAAiC,wGAA6C;AAC9E,sCAAsC,mGAAwC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0CAAa,oBAAoB;AACxE;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE,6BAA6B,0CAAa,mBAAmB;AAC7D;AACA;AACA;AACA;AACA,+BAA+B,yCAAY;AAC3C,iBAAiB,2EAAiB;AAClC;AACA;AACA;AACA;AACA,+BAA+B,sCAAS;AACxC;AACA;AACA,oBAAoB,uDAAW;AAC/B,oBAAoB,uDAAW;AAC/B,QAAQ,iFAAuB;AAC/B;AACA,YAAY,wFAA8B;AAC1C;AACA;AACA,gBAAgB,sFAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yCAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8DAAe;AAChD;AACA,wBAAwB,+FAAqC;AAC7D;AACA;AACA;AACA;AACA,2BAA2B,wDAAY;AACvC;AACA;AACA;;;;;;;;;;;;;;;;;;ACthBA;AACA;AAC+E;AAClD;AACtB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yCAAY,kBAAkB,qCAAQ;AACjE;AACA,eAAe;AACf,kFAAkF,qCAAQ;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sFAA4B;AAC9D;AACA,2CAA2C,6EAAmB;AAC9D,yCAAyC,sCAAS;AAClD,mDAAmD,yCAAY;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,kFAAwB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,qCAAQ;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA,mEAAmE,kCAAkC;AACrG;AACA;AACA;AACA,QAAQ,qEAAW;AACnB;AACA;AACA;AACA;;;;;;;;;;;;;;AC7FA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@microsoft/rush-lib/./lib-esnext/logic/deploy/DeployArchiver.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/deploy/DeployManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/deploy/SymlinkAnalyzer.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/deploy/Utils.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport JSZip from 'jszip';\nimport * as path from 'path';\nimport { FileSystem, Path } from '@rushstack/node-core-library';\nexport class DeployArchiver {\n    static async createArchiveAsync(deployState) {\n        if (deployState.createArchiveFilePath !== undefined) {\n            console.log('Creating archive...');\n            const zip = this._getZipOfFolder(deployState.targetRootFolder);\n            const zipContent = await zip.generateAsync({\n                type: 'nodebuffer',\n                platform: 'UNIX'\n            });\n            FileSystem.writeFile(path.resolve(deployState.targetRootFolder, deployState.createArchiveFilePath), zipContent);\n            console.log('Archive created successfully.');\n        }\n    }\n    static _getFilePathsRecursively(dir) {\n        // returns a flat array of absolute paths of all files recursively contained in the dir\n        let results = [];\n        const list = FileSystem.readFolderItemNames(dir);\n        if (!list.length)\n            return results;\n        for (let file of list) {\n            file = path.resolve(dir, file);\n            const stat = FileSystem.getLinkStatistics(file);\n            if (stat && stat.isDirectory()) {\n                results = results.concat(this._getFilePathsRecursively(file));\n            }\n            else {\n                results.push(file);\n            }\n        }\n        return results;\n    }\n    static _getZipOfFolder(dir) {\n        // returns a JSZip instance filled with contents of dir.\n        const allPaths = this._getFilePathsRecursively(dir);\n        // This value sets the allowed permissions when preserving symbolic links.\n        // 120000 is the symbolic link identifier, and 0755 designates the allowed permissions.\n        // See: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/stat.h#n10\n        const permissionsValue = 0o120755;\n        const zip = new JSZip();\n        for (const filePath of allPaths) {\n            // Get the relative path and replace backslashes for Unix compat\n            const addPath = Path.convertToSlashes(path.relative(dir, filePath));\n            const stat = FileSystem.getLinkStatistics(filePath);\n            const permissions = stat.mode;\n            if (stat.isSymbolicLink()) {\n                zip.file(addPath, FileSystem.readLink(filePath), {\n                    unixPermissions: permissionsValue,\n                    dir: stat.isDirectory()\n                });\n            }\n            else {\n                const data = FileSystem.readFileToBuffer(filePath);\n                zip.file(addPath, data, {\n                    unixPermissions: permissions,\n                    dir: stat.isDirectory()\n                });\n            }\n        }\n        return zip;\n    }\n}\n//# sourceMappingURL=DeployArchiver.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport colors from 'colors/safe';\nimport * as path from 'path';\nimport * as resolve from 'resolve';\nimport * as npmPacklist from 'npm-packlist';\nimport pnpmLinkBins from '@pnpm/link-bins';\n// (Used only by the legacy code fragment in the resolve.sync() hook below)\nimport * as fsForResolve from 'fs';\nimport ignore from 'ignore';\nimport { Path, FileSystem, PackageJsonLookup, Sort, JsonFile, AlreadyExistsBehavior, InternalError, NewlineKind, Text } from '@rushstack/node-core-library';\nimport { DeployArchiver } from './DeployArchiver';\nimport { SymlinkAnalyzer } from './SymlinkAnalyzer';\nimport { DeployScenarioConfiguration } from './DeployScenarioConfiguration';\nimport { PnpmfileConfiguration } from '../pnpm/PnpmfileConfiguration';\nimport { matchesWithStar } from './Utils';\nimport { createLinksScriptFilename, scriptsFolderPath } from '../../utilities/PathConstants';\n/**\n * Manages the business logic for the \"rush deploy\" command.\n */\nexport class DeployManager {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n        this._packageJsonLookup = new PackageJsonLookup();\n    }\n    /**\n     * Recursively crawl the node_modules dependencies and collect the result in IDeployState.foldersToCopy.\n     */\n    _collectFoldersRecursive(packageJsonFolderPath, deployState) {\n        const packageJsonRealFolderPath = FileSystem.getRealPath(packageJsonFolderPath);\n        if (deployState.foldersToCopy.has(packageJsonRealFolderPath)) {\n            // we've already seen this folder\n            return;\n        }\n        deployState.foldersToCopy.add(packageJsonRealFolderPath);\n        const originalPackageJson = JsonFile.load(path.join(packageJsonRealFolderPath, 'package.json'));\n        const sourceFolderInfo = deployState.folderInfosByPath.get(FileSystem.getRealPath(packageJsonFolderPath));\n        // Transform packageJson using pnpmfile.js if available\n        const packageJson = deployState.pnpmfileConfiguration\n            ? deployState.pnpmfileConfiguration.transform(originalPackageJson)\n            : originalPackageJson;\n        // Union of keys from regular dependencies, peerDependencies, optionalDependencies\n        // (and possibly devDependencies if includeDevDependencies=true)\n        const dependencyNamesToProcess = new Set();\n        // Just the keys from optionalDependencies and peerDependencies\n        const optionalDependencyNames = new Set();\n        for (const name of Object.keys(packageJson.dependencies || {})) {\n            dependencyNamesToProcess.add(name);\n        }\n        if (deployState.scenarioConfiguration.json.includeDevDependencies && (sourceFolderInfo === null || sourceFolderInfo === void 0 ? void 0 : sourceFolderInfo.isRushProject)) {\n            for (const name of Object.keys(packageJson.devDependencies || {})) {\n                dependencyNamesToProcess.add(name);\n            }\n        }\n        for (const name of Object.keys(packageJson.peerDependencies || {})) {\n            dependencyNamesToProcess.add(name);\n            optionalDependencyNames.add(name); // consider peers optional, since they are so frequently broken\n        }\n        for (const name of Object.keys(packageJson.optionalDependencies || {})) {\n            dependencyNamesToProcess.add(name);\n            optionalDependencyNames.add(name);\n        }\n        if (sourceFolderInfo && sourceFolderInfo.isRushProject) {\n            const projectSettings = sourceFolderInfo.projectSettings;\n            if (projectSettings) {\n                this._applyDependencyFilters(dependencyNamesToProcess, projectSettings.additionalDependenciesToInclude, projectSettings.dependenciesToExclude);\n            }\n        }\n        for (const dependencyPackageName of dependencyNamesToProcess) {\n            try {\n                this._traceResolveDependency(dependencyPackageName, packageJsonRealFolderPath, deployState);\n            }\n            catch (resolveErr) {\n                if (resolveErr.code === 'MODULE_NOT_FOUND' &&\n                    optionalDependencyNames.has(dependencyPackageName)) {\n                    // Ignore missing optional dependency\n                    continue;\n                }\n                throw resolveErr;\n            }\n        }\n        if (this._rushConfiguration.packageManager === 'pnpm' &&\n            !deployState.scenarioConfiguration.json.omitPnpmWorkaroundLinks) {\n            // Replicate the PNPM workaround links.\n            // Only apply this logic for packages that were actually installed under the common/temp folder.\n            if (Path.isUnder(packageJsonFolderPath, this._rushConfiguration.commonTempFolder)) {\n                try {\n                    // The PNPM workaround links are created in this folder.  We will resolve the current package\n                    // from that location and collect any additional links encountered along the way.\n                    const pnpmDotFolderPath = path.join(this._rushConfiguration.commonTempFolder, 'node_modules', '.pnpm');\n                    // TODO: Investigate how package aliases are handled by PNPM in this case.  For example:\n                    //\n                    // \"dependencies\": {\n                    //   \"alias-name\": \"npm:real-name@^1.2.3\"\n                    // }\n                    this._traceResolveDependency(packageJson.name, pnpmDotFolderPath, deployState);\n                }\n                catch (resolveErr) {\n                    if (resolveErr.code === 'MODULE_NOT_FOUND') {\n                        // The workaround link isn't guaranteed to exist, so ignore if it's missing\n                        // NOTE: If you encounter this warning a lot, please report it to the Rush maintainers.\n                        console.log('Ignoring missing PNPM workaround link for ' + packageJsonFolderPath);\n                    }\n                }\n            }\n        }\n    }\n    _applyDependencyFilters(allDependencyNames, additionalDependenciesToInclude = [], dependenciesToExclude = []) {\n        // Track packages that got added/removed for reporting purposes\n        const extraIncludedPackageNames = [];\n        const extraExcludedPackageNames = [];\n        for (const patternWithStar of dependenciesToExclude) {\n            for (const dependency of allDependencyNames) {\n                if (matchesWithStar(patternWithStar, dependency)) {\n                    if (allDependencyNames.delete(dependency)) {\n                        extraExcludedPackageNames.push(dependency);\n                    }\n                }\n            }\n        }\n        for (const dependencyToInclude of additionalDependenciesToInclude) {\n            if (!allDependencyNames.has(dependencyToInclude)) {\n                allDependencyNames.add(dependencyToInclude);\n                extraIncludedPackageNames.push(dependencyToInclude);\n            }\n        }\n        if (extraIncludedPackageNames.length > 0) {\n            extraIncludedPackageNames.sort();\n            console.log('Extra dependencies included by settings: ' + extraIncludedPackageNames.join(', '));\n        }\n        if (extraExcludedPackageNames.length > 0) {\n            extraExcludedPackageNames.sort();\n            console.log('Extra dependencies excluded by settings: ' + extraExcludedPackageNames.join(', '));\n        }\n        return allDependencyNames;\n    }\n    _traceResolveDependency(packageName, startingFolder, deployState) {\n        // The \"resolve\" library models the Node.js require() API, which gives precedence to \"core\" system modules\n        // over an NPM package with the same name.  But we are traversing package.json dependencies, which never\n        // refer to system modules.  Appending a \"/\" forces require() to look for the NPM package.\n        const resolveSuffix = packageName + resolve.isCore(packageName) ? '/' : '';\n        const resolvedDependency = resolve.sync(packageName + resolveSuffix, {\n            basedir: startingFolder,\n            preserveSymlinks: false,\n            packageFilter: (pkg, dir) => {\n                // point \"main\" at a file that is guaranteed to exist\n                // This helps resolve packages such as @types/node that have no entry point\n                pkg.main = './package.json';\n                return pkg;\n            },\n            realpathSync: (filePath) => {\n                // This code fragment is a modification of the documented default implementation from the \"fs-extra\" docs\n                try {\n                    const resolvedPath = fsForResolve.realpathSync(filePath);\n                    deployState.symlinkAnalyzer.analyzePath(filePath);\n                    return resolvedPath;\n                }\n                catch (realpathErr) {\n                    if (realpathErr.code !== 'ENOENT') {\n                        throw realpathErr;\n                    }\n                }\n                return filePath;\n            }\n        });\n        if (!resolvedDependency) {\n            // This should not happen, since the resolve.sync() docs say it will throw an exception instead\n            throw new InternalError(`Error resolving ${packageName} from ${startingFolder}`);\n        }\n        const dependencyPackageFolderPath = this._packageJsonLookup.tryGetPackageFolderFor(resolvedDependency);\n        if (!dependencyPackageFolderPath) {\n            throw new Error(`Error finding package.json folder for ${resolvedDependency}`);\n        }\n        this._collectFoldersRecursive(dependencyPackageFolderPath, deployState);\n    }\n    /**\n     * Maps a file path from IDeployState.sourceRootFolder --> IDeployState.targetRootFolder\n     *\n     * Example input: \"C:\\MyRepo\\libraries\\my-lib\"\n     * Example output: \"C:\\MyRepo\\common\\deploy\\libraries\\my-lib\"\n     */\n    _remapPathForDeployFolder(absolutePathInSourceFolder, deployState) {\n        if (!Path.isUnderOrEqual(absolutePathInSourceFolder, deployState.sourceRootFolder)) {\n            throw new Error(`Source path is not under ${deployState.sourceRootFolder}\\n${absolutePathInSourceFolder}`);\n        }\n        const relativePath = path.relative(deployState.sourceRootFolder, absolutePathInSourceFolder);\n        const absolutePathInTargetFolder = path.join(deployState.targetRootFolder, relativePath);\n        return absolutePathInTargetFolder;\n    }\n    /**\n     * Maps a file path from IDeployState.sourceRootFolder --> relative path\n     *\n     * Example input: \"C:\\MyRepo\\libraries\\my-lib\"\n     * Example output: \"libraries/my-lib\"\n     */\n    _remapPathForDeployMetadata(absolutePathInSourceFolder, deployState) {\n        if (!Path.isUnderOrEqual(absolutePathInSourceFolder, deployState.sourceRootFolder)) {\n            throw new Error(`Source path is not under ${deployState.sourceRootFolder}\\n${absolutePathInSourceFolder}`);\n        }\n        const relativePath = path.relative(deployState.sourceRootFolder, absolutePathInSourceFolder);\n        return Text.replaceAll(relativePath, '\\\\', '/');\n    }\n    /**\n     * Copy one package folder to the deployment target folder.\n     */\n    _deployFolder(sourceFolderPath, deployState) {\n        let useNpmIgnoreFilter = false;\n        if (!deployState.scenarioConfiguration.json.includeNpmIgnoreFiles) {\n            const sourceFolderInfo = deployState.folderInfosByPath.get(FileSystem.getRealPath(sourceFolderPath));\n            if (sourceFolderInfo) {\n                if (sourceFolderInfo.isRushProject) {\n                    useNpmIgnoreFilter = true;\n                }\n            }\n        }\n        const targetFolderPath = this._remapPathForDeployFolder(sourceFolderPath, deployState);\n        if (useNpmIgnoreFilter) {\n            // Use npm-packlist to filter the files.  Using the WalkerSync class (instead of the sync() API) ensures\n            // that \"bundledDependencies\" are not included.\n            const walker = new npmPacklist.WalkerSync({\n                path: sourceFolderPath\n            });\n            walker.start();\n            const npmPackFiles = walker.result;\n            const alreadyCopiedSourcePaths = new Set();\n            for (const npmPackFile of npmPackFiles) {\n                // In issue https://github.com/microsoft/rushstack/issues/2121 we found that npm-packlist sometimes returns\n                // duplicate file paths, for example:\n                //\n                //   'dist//index.js'\n                //   'dist/index.js'\n                //\n                // We can detect the duplicates by comparing the path.resolve() result.\n                const copySourcePath = path.resolve(sourceFolderPath, npmPackFile);\n                if (alreadyCopiedSourcePaths.has(copySourcePath)) {\n                    continue;\n                }\n                alreadyCopiedSourcePaths.add(copySourcePath);\n                const copyDestinationPath = path.join(targetFolderPath, npmPackFile);\n                if (deployState.symlinkAnalyzer.analyzePath(copySourcePath).kind !== 'link') {\n                    FileSystem.ensureFolder(path.dirname(copyDestinationPath));\n                    FileSystem.copyFile({\n                        sourcePath: copySourcePath,\n                        destinationPath: copyDestinationPath,\n                        alreadyExistsBehavior: AlreadyExistsBehavior.Error\n                    });\n                }\n            }\n        }\n        else {\n            // use a simplistic \"ignore\" ruleset to filter the files\n            const ignoreFilter = ignore();\n            ignoreFilter.add([\n                // The top-level node_modules folder is always excluded\n                '/node_modules',\n                // Also exclude well-known folders that can contribute a lot of unnecessary files\n                '**/.git',\n                '**/.svn',\n                '**/.hg',\n                '**/.DS_Store'\n            ]);\n            FileSystem.copyFiles({\n                sourcePath: sourceFolderPath,\n                destinationPath: targetFolderPath,\n                alreadyExistsBehavior: AlreadyExistsBehavior.Error,\n                filter: (src, dest) => {\n                    const relativeSrc = path.relative(sourceFolderPath, src);\n                    if (!relativeSrc) {\n                        return true; // don't filter sourceFolderPath itself\n                    }\n                    if (ignoreFilter.ignores(relativeSrc)) {\n                        return false;\n                    }\n                    const stats = FileSystem.getLinkStatistics(src);\n                    if (stats.isSymbolicLink()) {\n                        deployState.symlinkAnalyzer.analyzePath(src);\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * Create a symlink as described by the ILinkInfo object.\n     */\n    _deploySymlink(originalLinkInfo, deployState) {\n        const linkInfo = {\n            kind: originalLinkInfo.kind,\n            linkPath: this._remapPathForDeployFolder(originalLinkInfo.linkPath, deployState),\n            targetPath: this._remapPathForDeployFolder(originalLinkInfo.targetPath, deployState)\n        };\n        // Has the link target been created yet?  If not, we should try again later\n        if (!FileSystem.exists(linkInfo.targetPath)) {\n            return false;\n        }\n        const newLinkFolder = path.dirname(linkInfo.linkPath);\n        FileSystem.ensureFolder(newLinkFolder);\n        // Link to the relative path for symlinks\n        const relativeTargetPath = path.relative(newLinkFolder, linkInfo.targetPath);\n        // NOTE: This logic is based on NpmLinkManager._createSymlink()\n        if (process.platform === 'win32') {\n            if (linkInfo.kind === 'folderLink') {\n                // For directories, we use a Windows \"junction\".  On Unix, this produces a regular symlink.\n                FileSystem.createSymbolicLinkJunction({\n                    linkTargetPath: relativeTargetPath,\n                    newLinkPath: linkInfo.linkPath\n                });\n            }\n            else {\n                // For files, we use a Windows \"hard link\", because creating a symbolic link requires\n                // administrator permission.\n                // NOTE: We cannot use the relative path for hard links\n                FileSystem.createHardLink({\n                    linkTargetPath: relativeTargetPath,\n                    newLinkPath: linkInfo.linkPath\n                });\n            }\n        }\n        else {\n            // However hard links seem to cause build failures on Mac, so for all other operating systems\n            // we use symbolic links for this case.\n            if (linkInfo.kind === 'folderLink') {\n                FileSystem.createSymbolicLinkFolder({\n                    linkTargetPath: relativeTargetPath,\n                    newLinkPath: linkInfo.linkPath\n                });\n            }\n            else {\n                FileSystem.createSymbolicLinkFile({\n                    linkTargetPath: relativeTargetPath,\n                    newLinkPath: linkInfo.linkPath\n                });\n            }\n        }\n        return true;\n    }\n    /**\n     * Recursively apply the \"additionalProjectToInclude\" setting.\n     */\n    _collectAdditionalProjectsToInclude(includedProjectNamesSet, projectName, deployState) {\n        if (includedProjectNamesSet.has(projectName)) {\n            return;\n        }\n        includedProjectNamesSet.add(projectName);\n        const projectSettings = deployState.scenarioConfiguration.projectJsonsByName.get(projectName);\n        if (projectSettings && projectSettings.additionalProjectsToInclude) {\n            for (const additionalProjectToInclude of projectSettings.additionalProjectsToInclude) {\n                this._collectAdditionalProjectsToInclude(includedProjectNamesSet, additionalProjectToInclude, deployState);\n            }\n        }\n    }\n    /**\n     * Write the common/deploy/deploy-metadata.json file.\n     */\n    _writeDeployMetadata(deployState) {\n        const deployMetadataFilePath = path.join(deployState.targetRootFolder, 'deploy-metadata.json');\n        const deployMetadataJson = {\n            scenarioName: path.basename(deployState.scenarioFilePath),\n            mainProjectName: deployState.mainProjectName,\n            projects: [],\n            links: []\n        };\n        deployState.folderInfosByPath.forEach((folderInfo) => {\n            if (!folderInfo.isRushProject) {\n                // It's not a Rush project\n                return;\n            }\n            if (!deployState.foldersToCopy.has(folderInfo.folderPath)) {\n                // It's not something we crawled\n                return;\n            }\n            deployMetadataJson.projects.push({\n                path: this._remapPathForDeployMetadata(folderInfo.folderPath, deployState)\n            });\n        });\n        // Remap the links to be relative to target folder\n        for (const absoluteLinkInfo of deployState.symlinkAnalyzer.reportSymlinks()) {\n            const relativeInfo = {\n                kind: absoluteLinkInfo.kind,\n                linkPath: this._remapPathForDeployMetadata(absoluteLinkInfo.linkPath, deployState),\n                targetPath: this._remapPathForDeployMetadata(absoluteLinkInfo.targetPath, deployState)\n            };\n            deployMetadataJson.links.push(relativeInfo);\n        }\n        JsonFile.save(deployMetadataJson, deployMetadataFilePath, {\n            newlineConversion: NewlineKind.OsDefault\n        });\n    }\n    async _makeBinLinksAsync(deployState) {\n        for (const [, folderInfo] of deployState.folderInfosByPath) {\n            if (!folderInfo.isRushProject) {\n                return;\n            }\n            const deployedPath = this._remapPathForDeployMetadata(folderInfo.folderPath, deployState);\n            const projectFolder = path.join(deployState.targetRootFolder, deployedPath, 'node_modules');\n            const projectBinFolder = path.join(deployState.targetRootFolder, deployedPath, 'node_modules', '.bin');\n            await pnpmLinkBins(projectFolder, projectBinFolder, {\n                warn: (msg) => console.warn(colors.yellow(msg))\n            });\n        }\n    }\n    async _prepareDeploymentAsync(deployState) {\n        // Calculate the set with additionalProjectsToInclude\n        const includedProjectNamesSet = new Set();\n        this._collectAdditionalProjectsToInclude(includedProjectNamesSet, deployState.mainProjectName, deployState);\n        for (const rushProject of this._rushConfiguration.projects) {\n            const projectFolder = FileSystem.getRealPath(rushProject.projectFolder);\n            const projectSettings = deployState.scenarioConfiguration.projectJsonsByName.get(rushProject.packageName);\n            deployState.folderInfosByPath.set(projectFolder, {\n                folderPath: projectFolder,\n                isRushProject: true,\n                projectSettings\n            });\n        }\n        for (const projectName of includedProjectNamesSet) {\n            console.log(colors.cyan('Analyzing project: ') + projectName);\n            const project = this._rushConfiguration.getProjectByName(projectName);\n            if (!project) {\n                throw new Error(`The project ${projectName} is not defined in rush.json`);\n            }\n            this._collectFoldersRecursive(project.projectFolder, deployState);\n            console.log();\n        }\n        Sort.sortSet(deployState.foldersToCopy);\n        console.log('Copying folders...');\n        for (const folderToCopy of deployState.foldersToCopy) {\n            this._deployFolder(folderToCopy, deployState);\n        }\n        console.log('Writing deploy-metadata.json');\n        this._writeDeployMetadata(deployState);\n        if (deployState.scenarioConfiguration.json.linkCreation === 'script') {\n            console.log('Copying create-links.js');\n            FileSystem.copyFile({\n                sourcePath: `${scriptsFolderPath}/${createLinksScriptFilename}`,\n                destinationPath: path.join(deployState.targetRootFolder, 'create-links.js'),\n                alreadyExistsBehavior: AlreadyExistsBehavior.Error\n            });\n        }\n        if (deployState.scenarioConfiguration.json.linkCreation === 'default') {\n            console.log('Creating symlinks...');\n            const linksToCopy = deployState.symlinkAnalyzer.reportSymlinks();\n            for (const linkToCopy of linksToCopy) {\n                if (!this._deploySymlink(linkToCopy, deployState)) {\n                    // TODO: If a symbolic link points to another symbolic link, then we should order the operations\n                    // so that the intermediary target is created first.  This case was procrastinated because it does\n                    // not seem to occur in practice.  If you encounter this, please report it.\n                    throw new InternalError('Target does not exist: ' + JSON.stringify(linkToCopy, undefined, 2));\n                }\n            }\n            await this._makeBinLinksAsync(deployState);\n        }\n        if (deployState.scenarioConfiguration.json.folderToCopy !== undefined) {\n            const sourceFolderPath = path.resolve(this._rushConfiguration.rushJsonFolder, deployState.scenarioConfiguration.json.folderToCopy);\n            FileSystem.copyFiles({\n                sourcePath: sourceFolderPath,\n                destinationPath: deployState.targetRootFolder,\n                alreadyExistsBehavior: AlreadyExistsBehavior.Error\n            });\n        }\n        await DeployArchiver.createArchiveAsync(deployState);\n    }\n    /**\n     * The main entry point for performing a deployment.\n     */\n    async deployAsync(mainProjectName, scenarioName, overwriteExisting, targetFolderParameter, createArchiveFilePath) {\n        const scenarioFilePath = DeployScenarioConfiguration.getConfigFilePath(scenarioName, this._rushConfiguration);\n        const scenarioConfiguration = DeployScenarioConfiguration.loadFromFile(scenarioFilePath, this._rushConfiguration);\n        if (!mainProjectName) {\n            if (scenarioConfiguration.json.deploymentProjectNames.length === 1) {\n                // If there is only one project, then \"--project\" is optional\n                mainProjectName = scenarioConfiguration.json.deploymentProjectNames[0];\n            }\n            else {\n                throw new Error(`The ${path.basename(scenarioFilePath)} configuration specifies multiple items for` +\n                    ` \"deploymentProjectNames\". Use the \"--project\" parameter to indicate the project to be deployed.`);\n            }\n        }\n        else {\n            if (scenarioConfiguration.json.deploymentProjectNames.indexOf(mainProjectName) < 0) {\n                throw new Error(`The project \"${mainProjectName}\" does not appear in the list of \"deploymentProjectNames\"` +\n                    ` from ${path.basename(scenarioFilePath)}.`);\n            }\n        }\n        let targetRootFolder;\n        if (targetFolderParameter) {\n            targetRootFolder = path.resolve(targetFolderParameter);\n            if (!FileSystem.exists(targetRootFolder)) {\n                throw new Error('The specified target folder does not exist: ' + JSON.stringify(targetFolderParameter));\n            }\n        }\n        else {\n            targetRootFolder = path.join(this._rushConfiguration.commonFolder, 'deploy');\n        }\n        const sourceRootFolder = this._rushConfiguration.rushJsonFolder;\n        console.log(colors.cyan('Deploying to target folder:  ') + targetRootFolder);\n        console.log(colors.cyan('Main project for deployment: ') + mainProjectName + '\\n');\n        FileSystem.ensureFolder(targetRootFolder);\n        // Is the target folder empty?\n        if (FileSystem.readFolderItemNames(targetRootFolder).length > 0) {\n            if (overwriteExisting) {\n                console.log('Deleting target folder contents because \"--overwrite\" was specified...');\n                FileSystem.ensureEmptyFolder(targetRootFolder);\n                console.log();\n            }\n            else {\n                throw new Error('The deploy target folder is not empty. You can specify \"--overwrite\"' +\n                    ' to recursively delete all folder contents.');\n            }\n        }\n        // If create archive is set, ensure it has a legal extension\n        if (createArchiveFilePath && path.extname(createArchiveFilePath) !== '.zip') {\n            throw new Error('The \"--create-archive\" parameter currently only supports archives with the .zip file extension.');\n        }\n        const deployState = {\n            scenarioFilePath,\n            scenarioConfiguration,\n            mainProjectName,\n            sourceRootFolder,\n            targetRootFolder,\n            foldersToCopy: new Set(),\n            folderInfosByPath: new Map(),\n            symlinkAnalyzer: new SymlinkAnalyzer(),\n            pnpmfileConfiguration: this._rushConfiguration.packageManager === 'pnpm'\n                ? await PnpmfileConfiguration.initializeAsync(this._rushConfiguration)\n                : undefined,\n            createArchiveFilePath\n        };\n        await this._prepareDeploymentAsync(deployState);\n        console.log('\\n' + colors.green('The operation completed successfully.'));\n    }\n}\n//# sourceMappingURL=DeployManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, Sort, InternalError } from '@rushstack/node-core-library';\nimport * as path from 'path';\nexport class SymlinkAnalyzer {\n    constructor() {\n        // The directory tree discovered so far\n        this._nodesByPath = new Map();\n        // The symlinks that we encountered while building the directory tree\n        this._linkInfosByPath = new Map();\n    }\n    analyzePath(inputPath, preserveLinks = false) {\n        let pathSegments = path.resolve(inputPath).split(path.sep);\n        let pathSegmentsIndex = 0;\n        for (;;) {\n            const currentPath = pathSegments.slice(0, pathSegmentsIndex + 1).join(path.sep);\n            if (currentPath === '') {\n                // Edge case for a Unix path like \"/folder/file\" --> [ \"\", \"folder\", \"file\" ]\n                ++pathSegmentsIndex;\n                continue;\n            }\n            let currentNode = this._nodesByPath.get(currentPath);\n            if (currentNode === undefined) {\n                const linkStats = FileSystem.getLinkStatistics(currentPath);\n                if (linkStats.isSymbolicLink()) {\n                    const linkTargetPath = FileSystem.readLink(currentPath);\n                    const parentFolder = path.join(currentPath, '..');\n                    const resolvedLinkTargetPath = path.resolve(parentFolder, linkTargetPath);\n                    currentNode = {\n                        kind: 'link',\n                        nodePath: currentPath,\n                        linkTarget: resolvedLinkTargetPath\n                    };\n                }\n                else if (linkStats.isDirectory()) {\n                    currentNode = {\n                        kind: 'folder',\n                        nodePath: currentPath\n                    };\n                }\n                else if (linkStats.isFile()) {\n                    currentNode = {\n                        kind: 'file',\n                        nodePath: currentPath\n                    };\n                }\n                else {\n                    throw new Error('Unknown object type: ' + currentPath);\n                }\n                this._nodesByPath.set(currentPath, currentNode);\n            }\n            ++pathSegmentsIndex;\n            if (!preserveLinks) {\n                while (currentNode.kind === 'link') {\n                    const targetNode = this.analyzePath(currentNode.linkTarget, true);\n                    // Have we created an ILinkInfo for this link yet?\n                    if (!this._linkInfosByPath.has(currentNode.nodePath)) {\n                        // Follow any symbolic links to determine whether the final target is a directory\n                        const targetIsDirectory = FileSystem.getStatistics(targetNode.nodePath).isDirectory();\n                        const linkInfo = {\n                            kind: targetIsDirectory ? 'folderLink' : 'fileLink',\n                            linkPath: currentNode.nodePath,\n                            targetPath: targetNode.nodePath\n                        };\n                        this._linkInfosByPath.set(currentNode.nodePath, linkInfo);\n                    }\n                    const targetSegments = targetNode.nodePath.split(path.sep);\n                    const remainingSegments = pathSegments.slice(pathSegmentsIndex);\n                    pathSegments = [...targetSegments, ...remainingSegments];\n                    pathSegmentsIndex = targetSegments.length;\n                    currentNode = targetNode;\n                }\n            }\n            if (pathSegmentsIndex >= pathSegments.length) {\n                // We reached the end\n                return currentNode;\n            }\n            if (currentNode.kind !== 'folder') {\n                // This should never happen, because analyzePath() is always supposed to receive complete paths\n                // to real filesystem objects.\n                throw new InternalError('The path ends prematurely at: ' + inputPath);\n            }\n        }\n    }\n    /**\n     * Returns a summary of all the symbolic links encountered by {@link SymlinkAnalyzer.analyzePath}.\n     */\n    reportSymlinks() {\n        const list = [...this._linkInfosByPath.values()];\n        Sort.sortBy(list, (x) => x.linkPath);\n        return list;\n    }\n}\n//# sourceMappingURL=SymlinkAnalyzer.js.map","function escapeRegExp(literal) {\n    return literal.replace(/[^A-Za-z0-9_]/g, '\\\\$&');\n}\nexport function matchesWithStar(patternWithStar, input) {\n    // Map \"@types/*\" --> \"^\\@types\\/.*$\"\n    const pattern = '^' +\n        patternWithStar\n            .split('*')\n            .map((x) => escapeRegExp(x))\n            .join('.*') +\n        '$';\n    const regExp = new RegExp(pattern);\n    return regExp.test(input);\n}\n//# sourceMappingURL=Utils.js.map"],"names":[],"sourceRoot":""}