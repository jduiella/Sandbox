"use strict";
exports.id = "DeployManager";
exports.ids = ["DeployManager"];
exports.modules = {

/***/ 383494:
/*!***************************************************!*\
  !*** ./lib-esnext/logic/deploy/DeployArchiver.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeployArchiver": () => (/* binding */ DeployArchiver)
/* harmony export */ });
/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jszip */ 609227);
/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jszip__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



class DeployArchiver {
    static async createArchiveAsync(deployState) {
        if (deployState.createArchiveFilePath !== undefined) {
            console.log('Creating archive...');
            const zip = this._getZipOfFolder(deployState.targetRootFolder);
            const zipContent = await zip.generateAsync({
                type: 'nodebuffer',
                platform: 'UNIX'
            });
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.writeFile(path__WEBPACK_IMPORTED_MODULE_1__.resolve(deployState.targetRootFolder, deployState.createArchiveFilePath), zipContent);
            console.log('Archive created successfully.');
        }
    }
    static _getFilePathsRecursively(dir) {
        // returns a flat array of absolute paths of all files recursively contained in the dir
        let results = [];
        const list = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.readFolderItemNames(dir);
        if (!list.length)
            return results;
        for (let file of list) {
            file = path__WEBPACK_IMPORTED_MODULE_1__.resolve(dir, file);
            const stat = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.getLinkStatistics(file);
            if (stat && stat.isDirectory()) {
                results = results.concat(this._getFilePathsRecursively(file));
            }
            else {
                results.push(file);
            }
        }
        return results;
    }
    static _getZipOfFolder(dir) {
        // returns a JSZip instance filled with contents of dir.
        const allPaths = this._getFilePathsRecursively(dir);
        // This value sets the allowed permissions when preserving symbolic links.
        // 120000 is the symbolic link identifier, and 0755 designates the allowed permissions.
        // See: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/stat.h#n10
        const permissionsValue = 0o120755;
        const zip = new (jszip__WEBPACK_IMPORTED_MODULE_0___default())();
        for (const filePath of allPaths) {
            // Get the relative path and replace backslashes for Unix compat
            const addPath = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.Path.convertToSlashes(path__WEBPACK_IMPORTED_MODULE_1__.relative(dir, filePath));
            const stat = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.getLinkStatistics(filePath);
            const permissions = stat.mode;
            if (stat.isSymbolicLink()) {
                zip.file(addPath, _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.readLink(filePath), {
                    unixPermissions: permissionsValue,
                    dir: stat.isDirectory()
                });
            }
            else {
                const data = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_2__.FileSystem.readFileToBuffer(filePath);
                zip.file(addPath, data, {
                    unixPermissions: permissions,
                    dir: stat.isDirectory()
                });
            }
        }
        return zip;
    }
}
//# sourceMappingURL=DeployArchiver.js.map

/***/ }),

/***/ 547868:
/*!**************************************************!*\
  !*** ./lib-esnext/logic/deploy/DeployManager.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeployManager": () => (/* binding */ DeployManager)
/* harmony export */ });
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colors/safe */ 623211);
/* harmony import */ var colors_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colors_safe__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var resolve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! resolve */ 288048);
/* harmony import */ var resolve__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(resolve__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var npm_packlist__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! npm-packlist */ 172644);
/* harmony import */ var npm_packlist__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(npm_packlist__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _pnpm_link_bins__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @pnpm/link-bins */ 567726);
/* harmony import */ var _pnpm_link_bins__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_pnpm_link_bins__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! fs */ 657147);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var ignore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ignore */ 493511);
/* harmony import */ var ignore__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ignore__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _DeployArchiver__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./DeployArchiver */ 383494);
/* harmony import */ var _SymlinkAnalyzer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./SymlinkAnalyzer */ 670431);
/* harmony import */ var _DeployScenarioConfiguration__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./DeployScenarioConfiguration */ 544987);
/* harmony import */ var _pnpm_PnpmfileConfiguration__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../pnpm/PnpmfileConfiguration */ 238032);
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Utils */ 228386);
/* harmony import */ var _utilities_PathConstants__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/PathConstants */ 287644);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.





// (Used only by the legacy code fragment in the resolve.sync() hook below)









/**
 * Manages the business logic for the "rush deploy" command.
 */
class DeployManager {
    constructor(rushConfiguration) {
        this._rushConfiguration = rushConfiguration;
        this._packageJsonLookup = new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.PackageJsonLookup();
    }
    /**
     * Recursively crawl the node_modules dependencies and collect the result in IDeployState.foldersToCopy.
     */
    _collectFoldersRecursive(packageJsonFolderPath, deployState) {
        const packageJsonRealFolderPath = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.getRealPath(packageJsonFolderPath);
        if (deployState.foldersToCopy.has(packageJsonRealFolderPath)) {
            // we've already seen this folder
            return;
        }
        deployState.foldersToCopy.add(packageJsonRealFolderPath);
        const originalPackageJson = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.JsonFile.load(path__WEBPACK_IMPORTED_MODULE_1__.join(packageJsonRealFolderPath, 'package.json'));
        const sourceFolderInfo = deployState.folderInfosByPath.get(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.getRealPath(packageJsonFolderPath));
        // Transform packageJson using pnpmfile.js if available
        const packageJson = deployState.pnpmfileConfiguration
            ? deployState.pnpmfileConfiguration.transform(originalPackageJson)
            : originalPackageJson;
        // Union of keys from regular dependencies, peerDependencies, optionalDependencies
        // (and possibly devDependencies if includeDevDependencies=true)
        const dependencyNamesToProcess = new Set();
        // Just the keys from optionalDependencies and peerDependencies
        const optionalDependencyNames = new Set();
        for (const name of Object.keys(packageJson.dependencies || {})) {
            dependencyNamesToProcess.add(name);
        }
        if (deployState.scenarioConfiguration.json.includeDevDependencies && (sourceFolderInfo === null || sourceFolderInfo === void 0 ? void 0 : sourceFolderInfo.isRushProject)) {
            for (const name of Object.keys(packageJson.devDependencies || {})) {
                dependencyNamesToProcess.add(name);
            }
        }
        for (const name of Object.keys(packageJson.peerDependencies || {})) {
            dependencyNamesToProcess.add(name);
            optionalDependencyNames.add(name); // consider peers optional, since they are so frequently broken
        }
        for (const name of Object.keys(packageJson.optionalDependencies || {})) {
            dependencyNamesToProcess.add(name);
            optionalDependencyNames.add(name);
        }
        if (sourceFolderInfo && sourceFolderInfo.isRushProject) {
            const projectSettings = sourceFolderInfo.projectSettings;
            if (projectSettings) {
                this._applyDependencyFilters(dependencyNamesToProcess, projectSettings.additionalDependenciesToInclude, projectSettings.dependenciesToExclude);
            }
        }
        for (const dependencyPackageName of dependencyNamesToProcess) {
            try {
                this._traceResolveDependency(dependencyPackageName, packageJsonRealFolderPath, deployState);
            }
            catch (resolveErr) {
                if (resolveErr.code === 'MODULE_NOT_FOUND' &&
                    optionalDependencyNames.has(dependencyPackageName)) {
                    // Ignore missing optional dependency
                    continue;
                }
                throw resolveErr;
            }
        }
        if (this._rushConfiguration.packageManager === 'pnpm' &&
            !deployState.scenarioConfiguration.json.omitPnpmWorkaroundLinks) {
            // Replicate the PNPM workaround links.
            // Only apply this logic for packages that were actually installed under the common/temp folder.
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.Path.isUnder(packageJsonFolderPath, this._rushConfiguration.commonTempFolder)) {
                try {
                    // The PNPM workaround links are created in this folder.  We will resolve the current package
                    // from that location and collect any additional links encountered along the way.
                    const pnpmDotFolderPath = path__WEBPACK_IMPORTED_MODULE_1__.join(this._rushConfiguration.commonTempFolder, 'node_modules', '.pnpm');
                    // TODO: Investigate how package aliases are handled by PNPM in this case.  For example:
                    //
                    // "dependencies": {
                    //   "alias-name": "npm:real-name@^1.2.3"
                    // }
                    this._traceResolveDependency(packageJson.name, pnpmDotFolderPath, deployState);
                }
                catch (resolveErr) {
                    if (resolveErr.code === 'MODULE_NOT_FOUND') {
                        // The workaround link isn't guaranteed to exist, so ignore if it's missing
                        // NOTE: If you encounter this warning a lot, please report it to the Rush maintainers.
                        console.log('Ignoring missing PNPM workaround link for ' + packageJsonFolderPath);
                    }
                }
            }
        }
    }
    _applyDependencyFilters(allDependencyNames, additionalDependenciesToInclude = [], dependenciesToExclude = []) {
        // Track packages that got added/removed for reporting purposes
        const extraIncludedPackageNames = [];
        const extraExcludedPackageNames = [];
        for (const patternWithStar of dependenciesToExclude) {
            for (const dependency of allDependencyNames) {
                if ((0,_Utils__WEBPACK_IMPORTED_MODULE_8__.matchesWithStar)(patternWithStar, dependency)) {
                    if (allDependencyNames.delete(dependency)) {
                        extraExcludedPackageNames.push(dependency);
                    }
                }
            }
        }
        for (const dependencyToInclude of additionalDependenciesToInclude) {
            if (!allDependencyNames.has(dependencyToInclude)) {
                allDependencyNames.add(dependencyToInclude);
                extraIncludedPackageNames.push(dependencyToInclude);
            }
        }
        if (extraIncludedPackageNames.length > 0) {
            extraIncludedPackageNames.sort();
            console.log('Extra dependencies included by settings: ' + extraIncludedPackageNames.join(', '));
        }
        if (extraExcludedPackageNames.length > 0) {
            extraExcludedPackageNames.sort();
            console.log('Extra dependencies excluded by settings: ' + extraExcludedPackageNames.join(', '));
        }
        return allDependencyNames;
    }
    _traceResolveDependency(packageName, startingFolder, deployState) {
        // The "resolve" library models the Node.js require() API, which gives precedence to "core" system modules
        // over an NPM package with the same name.  But we are traversing package.json dependencies, which never
        // refer to system modules.  Appending a "/" forces require() to look for the NPM package.
        const resolveSuffix = packageName + resolve__WEBPACK_IMPORTED_MODULE_2__.isCore(packageName) ? '/' : '';
        const resolvedDependency = resolve__WEBPACK_IMPORTED_MODULE_2__.sync(packageName + resolveSuffix, {
            basedir: startingFolder,
            preserveSymlinks: false,
            packageFilter: (pkg, dir) => {
                // point "main" at a file that is guaranteed to exist
                // This helps resolve packages such as @types/node that have no entry point
                pkg.main = './package.json';
                return pkg;
            },
            realpathSync: (filePath) => {
                // This code fragment is a modification of the documented default implementation from the "fs-extra" docs
                try {
                    const resolvedPath = fs__WEBPACK_IMPORTED_MODULE_5__.realpathSync(filePath);
                    deployState.symlinkAnalyzer.analyzePath(filePath);
                    return resolvedPath;
                }
                catch (realpathErr) {
                    if (realpathErr.code !== 'ENOENT') {
                        throw realpathErr;
                    }
                }
                return filePath;
            }
        });
        if (!resolvedDependency) {
            // This should not happen, since the resolve.sync() docs say it will throw an exception instead
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.InternalError(`Error resolving ${packageName} from ${startingFolder}`);
        }
        const dependencyPackageFolderPath = this._packageJsonLookup.tryGetPackageFolderFor(resolvedDependency);
        if (!dependencyPackageFolderPath) {
            throw new Error(`Error finding package.json folder for ${resolvedDependency}`);
        }
        this._collectFoldersRecursive(dependencyPackageFolderPath, deployState);
    }
    /**
     * Maps a file path from IDeployState.sourceRootFolder --> IDeployState.targetRootFolder
     *
     * Example input: "C:\MyRepo\libraries\my-lib"
     * Example output: "C:\MyRepo\common\deploy\libraries\my-lib"
     */
    _remapPathForDeployFolder(absolutePathInSourceFolder, deployState) {
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.Path.isUnderOrEqual(absolutePathInSourceFolder, deployState.sourceRootFolder)) {
            throw new Error(`Source path is not under ${deployState.sourceRootFolder}\n${absolutePathInSourceFolder}`);
        }
        const relativePath = path__WEBPACK_IMPORTED_MODULE_1__.relative(deployState.sourceRootFolder, absolutePathInSourceFolder);
        const absolutePathInTargetFolder = path__WEBPACK_IMPORTED_MODULE_1__.join(deployState.targetRootFolder, relativePath);
        return absolutePathInTargetFolder;
    }
    /**
     * Maps a file path from IDeployState.sourceRootFolder --> relative path
     *
     * Example input: "C:\MyRepo\libraries\my-lib"
     * Example output: "libraries/my-lib"
     */
    _remapPathForDeployMetadata(absolutePathInSourceFolder, deployState) {
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.Path.isUnderOrEqual(absolutePathInSourceFolder, deployState.sourceRootFolder)) {
            throw new Error(`Source path is not under ${deployState.sourceRootFolder}\n${absolutePathInSourceFolder}`);
        }
        const relativePath = path__WEBPACK_IMPORTED_MODULE_1__.relative(deployState.sourceRootFolder, absolutePathInSourceFolder);
        return _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.Text.replaceAll(relativePath, '\\', '/');
    }
    /**
     * Copy one package folder to the deployment target folder.
     */
    _deployFolder(sourceFolderPath, deployState) {
        let useNpmIgnoreFilter = false;
        if (!deployState.scenarioConfiguration.json.includeNpmIgnoreFiles) {
            const sourceFolderInfo = deployState.folderInfosByPath.get(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.getRealPath(sourceFolderPath));
            if (sourceFolderInfo) {
                if (sourceFolderInfo.isRushProject) {
                    useNpmIgnoreFilter = true;
                }
            }
        }
        const targetFolderPath = this._remapPathForDeployFolder(sourceFolderPath, deployState);
        if (useNpmIgnoreFilter) {
            // Use npm-packlist to filter the files.  Using the WalkerSync class (instead of the sync() API) ensures
            // that "bundledDependencies" are not included.
            const walker = new npm_packlist__WEBPACK_IMPORTED_MODULE_3__.WalkerSync({
                path: sourceFolderPath
            });
            walker.start();
            const npmPackFiles = walker.result;
            const alreadyCopiedSourcePaths = new Set();
            for (const npmPackFile of npmPackFiles) {
                // In issue https://github.com/microsoft/rushstack/issues/2121 we found that npm-packlist sometimes returns
                // duplicate file paths, for example:
                //
                //   'dist//index.js'
                //   'dist/index.js'
                //
                // We can detect the duplicates by comparing the path.resolve() result.
                const copySourcePath = path__WEBPACK_IMPORTED_MODULE_1__.resolve(sourceFolderPath, npmPackFile);
                if (alreadyCopiedSourcePaths.has(copySourcePath)) {
                    continue;
                }
                alreadyCopiedSourcePaths.add(copySourcePath);
                const copyDestinationPath = path__WEBPACK_IMPORTED_MODULE_1__.join(targetFolderPath, npmPackFile);
                if (deployState.symlinkAnalyzer.analyzePath(copySourcePath).kind !== 'link') {
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.ensureFolder(path__WEBPACK_IMPORTED_MODULE_1__.dirname(copyDestinationPath));
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.copyFile({
                        sourcePath: copySourcePath,
                        destinationPath: copyDestinationPath,
                        alreadyExistsBehavior: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.AlreadyExistsBehavior.Error
                    });
                }
            }
        }
        else {
            // use a simplistic "ignore" ruleset to filter the files
            const ignoreFilter = ignore__WEBPACK_IMPORTED_MODULE_6___default()();
            ignoreFilter.add([
                // The top-level node_modules folder is always excluded
                '/node_modules',
                // Also exclude well-known folders that can contribute a lot of unnecessary files
                '**/.git',
                '**/.svn',
                '**/.hg',
                '**/.DS_Store'
            ]);
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.copyFiles({
                sourcePath: sourceFolderPath,
                destinationPath: targetFolderPath,
                alreadyExistsBehavior: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.AlreadyExistsBehavior.Error,
                filter: (src, dest) => {
                    const relativeSrc = path__WEBPACK_IMPORTED_MODULE_1__.relative(sourceFolderPath, src);
                    if (!relativeSrc) {
                        return true; // don't filter sourceFolderPath itself
                    }
                    if (ignoreFilter.ignores(relativeSrc)) {
                        return false;
                    }
                    const stats = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.getLinkStatistics(src);
                    if (stats.isSymbolicLink()) {
                        deployState.symlinkAnalyzer.analyzePath(src);
                        return false;
                    }
                    else {
                        return true;
                    }
                }
            });
        }
    }
    /**
     * Create a symlink as described by the ILinkInfo object.
     */
    _deploySymlink(originalLinkInfo, deployState) {
        const linkInfo = {
            kind: originalLinkInfo.kind,
            linkPath: this._remapPathForDeployFolder(originalLinkInfo.linkPath, deployState),
            targetPath: this._remapPathForDeployFolder(originalLinkInfo.targetPath, deployState)
        };
        // Has the link target been created yet?  If not, we should try again later
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.exists(linkInfo.targetPath)) {
            return false;
        }
        const newLinkFolder = path__WEBPACK_IMPORTED_MODULE_1__.dirname(linkInfo.linkPath);
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.ensureFolder(newLinkFolder);
        // Link to the relative path for symlinks
        const relativeTargetPath = path__WEBPACK_IMPORTED_MODULE_1__.relative(newLinkFolder, linkInfo.targetPath);
        // NOTE: This logic is based on NpmLinkManager._createSymlink()
        if (process.platform === 'win32') {
            if (linkInfo.kind === 'folderLink') {
                // For directories, we use a Windows "junction".  On Unix, this produces a regular symlink.
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.createSymbolicLinkJunction({
                    linkTargetPath: relativeTargetPath,
                    newLinkPath: linkInfo.linkPath
                });
            }
            else {
                // For files, we use a Windows "hard link", because creating a symbolic link requires
                // administrator permission.
                // NOTE: We cannot use the relative path for hard links
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.createHardLink({
                    linkTargetPath: relativeTargetPath,
                    newLinkPath: linkInfo.linkPath
                });
            }
        }
        else {
            // However hard links seem to cause build failures on Mac, so for all other operating systems
            // we use symbolic links for this case.
            if (linkInfo.kind === 'folderLink') {
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.createSymbolicLinkFolder({
                    linkTargetPath: relativeTargetPath,
                    newLinkPath: linkInfo.linkPath
                });
            }
            else {
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.createSymbolicLinkFile({
                    linkTargetPath: relativeTargetPath,
                    newLinkPath: linkInfo.linkPath
                });
            }
        }
        return true;
    }
    /**
     * Recursively apply the "additionalProjectToInclude" setting.
     */
    _collectAdditionalProjectsToInclude(includedProjectNamesSet, projectName, deployState) {
        if (includedProjectNamesSet.has(projectName)) {
            return;
        }
        includedProjectNamesSet.add(projectName);
        const projectSettings = deployState.scenarioConfiguration.projectJsonsByName.get(projectName);
        if (projectSettings && projectSettings.additionalProjectsToInclude) {
            for (const additionalProjectToInclude of projectSettings.additionalProjectsToInclude) {
                this._collectAdditionalProjectsToInclude(includedProjectNamesSet, additionalProjectToInclude, deployState);
            }
        }
    }
    /**
     * Write the common/deploy/deploy-metadata.json file.
     */
    _writeDeployMetadata(deployState) {
        const deployMetadataFilePath = path__WEBPACK_IMPORTED_MODULE_1__.join(deployState.targetRootFolder, 'deploy-metadata.json');
        const deployMetadataJson = {
            scenarioName: path__WEBPACK_IMPORTED_MODULE_1__.basename(deployState.scenarioFilePath),
            mainProjectName: deployState.mainProjectName,
            projects: [],
            links: []
        };
        deployState.folderInfosByPath.forEach((folderInfo) => {
            if (!folderInfo.isRushProject) {
                // It's not a Rush project
                return;
            }
            if (!deployState.foldersToCopy.has(folderInfo.folderPath)) {
                // It's not something we crawled
                return;
            }
            deployMetadataJson.projects.push({
                path: this._remapPathForDeployMetadata(folderInfo.folderPath, deployState)
            });
        });
        // Remap the links to be relative to target folder
        for (const absoluteLinkInfo of deployState.symlinkAnalyzer.reportSymlinks()) {
            const relativeInfo = {
                kind: absoluteLinkInfo.kind,
                linkPath: this._remapPathForDeployMetadata(absoluteLinkInfo.linkPath, deployState),
                targetPath: this._remapPathForDeployMetadata(absoluteLinkInfo.targetPath, deployState)
            };
            deployMetadataJson.links.push(relativeInfo);
        }
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.JsonFile.save(deployMetadataJson, deployMetadataFilePath, {
            newlineConversion: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.NewlineKind.OsDefault
        });
    }
    async _makeBinLinksAsync(deployState) {
        for (const [, folderInfo] of deployState.folderInfosByPath) {
            if (!folderInfo.isRushProject) {
                return;
            }
            const deployedPath = this._remapPathForDeployMetadata(folderInfo.folderPath, deployState);
            const projectFolder = path__WEBPACK_IMPORTED_MODULE_1__.join(deployState.targetRootFolder, deployedPath, 'node_modules');
            const projectBinFolder = path__WEBPACK_IMPORTED_MODULE_1__.join(deployState.targetRootFolder, deployedPath, 'node_modules', '.bin');
            await _pnpm_link_bins__WEBPACK_IMPORTED_MODULE_4___default()(projectFolder, projectBinFolder, {
                warn: (msg) => console.warn(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().yellow(msg))
            });
        }
    }
    async _prepareDeploymentAsync(deployState) {
        // Calculate the set with additionalProjectsToInclude
        const includedProjectNamesSet = new Set();
        this._collectAdditionalProjectsToInclude(includedProjectNamesSet, deployState.mainProjectName, deployState);
        for (const rushProject of this._rushConfiguration.projects) {
            const projectFolder = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.getRealPath(rushProject.projectFolder);
            const projectSettings = deployState.scenarioConfiguration.projectJsonsByName.get(rushProject.packageName);
            deployState.folderInfosByPath.set(projectFolder, {
                folderPath: projectFolder,
                isRushProject: true,
                projectSettings
            });
        }
        for (const projectName of includedProjectNamesSet) {
            console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().cyan('Analyzing project: ') + projectName);
            const project = this._rushConfiguration.getProjectByName(projectName);
            if (!project) {
                throw new Error(`The project ${projectName} is not defined in rush.json`);
            }
            this._collectFoldersRecursive(project.projectFolder, deployState);
            console.log();
        }
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.Sort.sortSet(deployState.foldersToCopy);
        console.log('Copying folders...');
        for (const folderToCopy of deployState.foldersToCopy) {
            this._deployFolder(folderToCopy, deployState);
        }
        console.log('Writing deploy-metadata.json');
        this._writeDeployMetadata(deployState);
        if (deployState.scenarioConfiguration.json.linkCreation === 'script') {
            console.log('Copying create-links.js');
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.copyFile({
                sourcePath: `${_utilities_PathConstants__WEBPACK_IMPORTED_MODULE_9__.scriptsFolderPath}/${_utilities_PathConstants__WEBPACK_IMPORTED_MODULE_9__.createLinksScriptFilename}`,
                destinationPath: path__WEBPACK_IMPORTED_MODULE_1__.join(deployState.targetRootFolder, 'create-links.js'),
                alreadyExistsBehavior: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.AlreadyExistsBehavior.Error
            });
        }
        if (deployState.scenarioConfiguration.json.linkCreation === 'default') {
            console.log('Creating symlinks...');
            const linksToCopy = deployState.symlinkAnalyzer.reportSymlinks();
            for (const linkToCopy of linksToCopy) {
                if (!this._deploySymlink(linkToCopy, deployState)) {
                    // TODO: If a symbolic link points to another symbolic link, then we should order the operations
                    // so that the intermediary target is created first.  This case was procrastinated because it does
                    // not seem to occur in practice.  If you encounter this, please report it.
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.InternalError('Target does not exist: ' + JSON.stringify(linkToCopy, undefined, 2));
                }
            }
            await this._makeBinLinksAsync(deployState);
        }
        if (deployState.scenarioConfiguration.json.folderToCopy !== undefined) {
            const sourceFolderPath = path__WEBPACK_IMPORTED_MODULE_1__.resolve(this._rushConfiguration.rushJsonFolder, deployState.scenarioConfiguration.json.folderToCopy);
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.copyFiles({
                sourcePath: sourceFolderPath,
                destinationPath: deployState.targetRootFolder,
                alreadyExistsBehavior: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.AlreadyExistsBehavior.Error
            });
        }
        await _DeployArchiver__WEBPACK_IMPORTED_MODULE_10__.DeployArchiver.createArchiveAsync(deployState);
    }
    /**
     * The main entry point for performing a deployment.
     */
    async deployAsync(mainProjectName, scenarioName, overwriteExisting, targetFolderParameter, createArchiveFilePath) {
        const scenarioFilePath = _DeployScenarioConfiguration__WEBPACK_IMPORTED_MODULE_11__.DeployScenarioConfiguration.getConfigFilePath(scenarioName, this._rushConfiguration);
        const scenarioConfiguration = _DeployScenarioConfiguration__WEBPACK_IMPORTED_MODULE_11__.DeployScenarioConfiguration.loadFromFile(scenarioFilePath, this._rushConfiguration);
        if (!mainProjectName) {
            if (scenarioConfiguration.json.deploymentProjectNames.length === 1) {
                // If there is only one project, then "--project" is optional
                mainProjectName = scenarioConfiguration.json.deploymentProjectNames[0];
            }
            else {
                throw new Error(`The ${path__WEBPACK_IMPORTED_MODULE_1__.basename(scenarioFilePath)} configuration specifies multiple items for` +
                    ` "deploymentProjectNames". Use the "--project" parameter to indicate the project to be deployed.`);
            }
        }
        else {
            if (scenarioConfiguration.json.deploymentProjectNames.indexOf(mainProjectName) < 0) {
                throw new Error(`The project "${mainProjectName}" does not appear in the list of "deploymentProjectNames"` +
                    ` from ${path__WEBPACK_IMPORTED_MODULE_1__.basename(scenarioFilePath)}.`);
            }
        }
        let targetRootFolder;
        if (targetFolderParameter) {
            targetRootFolder = path__WEBPACK_IMPORTED_MODULE_1__.resolve(targetFolderParameter);
            if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.exists(targetRootFolder)) {
                throw new Error('The specified target folder does not exist: ' + JSON.stringify(targetFolderParameter));
            }
        }
        else {
            targetRootFolder = path__WEBPACK_IMPORTED_MODULE_1__.join(this._rushConfiguration.commonFolder, 'deploy');
        }
        const sourceRootFolder = this._rushConfiguration.rushJsonFolder;
        console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().cyan('Deploying to target folder:  ') + targetRootFolder);
        console.log(colors_safe__WEBPACK_IMPORTED_MODULE_0___default().cyan('Main project for deployment: ') + mainProjectName + '\n');
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.ensureFolder(targetRootFolder);
        // Is the target folder empty?
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.readFolderItemNames(targetRootFolder).length > 0) {
            if (overwriteExisting) {
                console.log('Deleting target folder contents because "--overwrite" was specified...');
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_7__.FileSystem.ensureEmptyFolder(targetRootFolder);
                console.log();
            }
            else {
                throw new Error('The deploy target folder is not empty. You can specify "--overwrite"' +
                    ' to recursively delete all folder contents.');
            }
        }
        // If create archive is set, ensure it has a legal extension
        if (createArchiveFilePath && path__WEBPACK_IMPORTED_MODULE_1__.extname(createArchiveFilePath) !== '.zip') {
            throw new Error('The "--create-archive" parameter currently only supports archives with the .zip file extension.');
        }
        const deployState = {
            scenarioFilePath,
            scenarioConfiguration,
            mainProjectName,
            sourceRootFolder,
            targetRootFolder,
            foldersToCopy: new Set(),
            folderInfosByPath: new Map(),
            symlinkAnalyzer: new _SymlinkAnalyzer__WEBPACK_IMPORTED_MODULE_12__.SymlinkAnalyzer(),
            pnpmfileConfiguration: this._rushConfiguration.packageManager === 'pnpm'
                ? await _pnpm_PnpmfileConfiguration__WEBPACK_IMPORTED_MODULE_13__.PnpmfileConfiguration.initializeAsync(this._rushConfiguration)
                : undefined,
            createArchiveFilePath
        };
        await this._prepareDeploymentAsync(deployState);
        console.log('\n' + colors_safe__WEBPACK_IMPORTED_MODULE_0___default().green('The operation completed successfully.'));
    }
}
//# sourceMappingURL=DeployManager.js.map

/***/ }),

/***/ 670431:
/*!****************************************************!*\
  !*** ./lib-esnext/logic/deploy/SymlinkAnalyzer.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SymlinkAnalyzer": () => (/* binding */ SymlinkAnalyzer)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 132939);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 371017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.


class SymlinkAnalyzer {
    constructor() {
        // The directory tree discovered so far
        this._nodesByPath = new Map();
        // The symlinks that we encountered while building the directory tree
        this._linkInfosByPath = new Map();
    }
    analyzePath(inputPath, preserveLinks = false) {
        let pathSegments = path__WEBPACK_IMPORTED_MODULE_1__.resolve(inputPath).split(path__WEBPACK_IMPORTED_MODULE_1__.sep);
        let pathSegmentsIndex = 0;
        for (;;) {
            const currentPath = pathSegments.slice(0, pathSegmentsIndex + 1).join(path__WEBPACK_IMPORTED_MODULE_1__.sep);
            if (currentPath === '') {
                // Edge case for a Unix path like "/folder/file" --> [ "", "folder", "file" ]
                ++pathSegmentsIndex;
                continue;
            }
            let currentNode = this._nodesByPath.get(currentPath);
            if (currentNode === undefined) {
                const linkStats = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.getLinkStatistics(currentPath);
                if (linkStats.isSymbolicLink()) {
                    const linkTargetPath = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.readLink(currentPath);
                    const parentFolder = path__WEBPACK_IMPORTED_MODULE_1__.join(currentPath, '..');
                    const resolvedLinkTargetPath = path__WEBPACK_IMPORTED_MODULE_1__.resolve(parentFolder, linkTargetPath);
                    currentNode = {
                        kind: 'link',
                        nodePath: currentPath,
                        linkTarget: resolvedLinkTargetPath
                    };
                }
                else if (linkStats.isDirectory()) {
                    currentNode = {
                        kind: 'folder',
                        nodePath: currentPath
                    };
                }
                else if (linkStats.isFile()) {
                    currentNode = {
                        kind: 'file',
                        nodePath: currentPath
                    };
                }
                else {
                    throw new Error('Unknown object type: ' + currentPath);
                }
                this._nodesByPath.set(currentPath, currentNode);
            }
            ++pathSegmentsIndex;
            if (!preserveLinks) {
                while (currentNode.kind === 'link') {
                    const targetNode = this.analyzePath(currentNode.linkTarget, true);
                    // Have we created an ILinkInfo for this link yet?
                    if (!this._linkInfosByPath.has(currentNode.nodePath)) {
                        // Follow any symbolic links to determine whether the final target is a directory
                        const targetIsDirectory = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.getStatistics(targetNode.nodePath).isDirectory();
                        const linkInfo = {
                            kind: targetIsDirectory ? 'folderLink' : 'fileLink',
                            linkPath: currentNode.nodePath,
                            targetPath: targetNode.nodePath
                        };
                        this._linkInfosByPath.set(currentNode.nodePath, linkInfo);
                    }
                    const targetSegments = targetNode.nodePath.split(path__WEBPACK_IMPORTED_MODULE_1__.sep);
                    const remainingSegments = pathSegments.slice(pathSegmentsIndex);
                    pathSegments = [...targetSegments, ...remainingSegments];
                    pathSegmentsIndex = targetSegments.length;
                    currentNode = targetNode;
                }
            }
            if (pathSegmentsIndex >= pathSegments.length) {
                // We reached the end
                return currentNode;
            }
            if (currentNode.kind !== 'folder') {
                // This should never happen, because analyzePath() is always supposed to receive complete paths
                // to real filesystem objects.
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.InternalError('The path ends prematurely at: ' + inputPath);
            }
        }
    }
    /**
     * Returns a summary of all the symbolic links encountered by {@link SymlinkAnalyzer.analyzePath}.
     */
    reportSymlinks() {
        const list = [...this._linkInfosByPath.values()];
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Sort.sortBy(list, (x) => x.linkPath);
        return list;
    }
}
//# sourceMappingURL=SymlinkAnalyzer.js.map

/***/ }),

/***/ 228386:
/*!******************************************!*\
  !*** ./lib-esnext/logic/deploy/Utils.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "matchesWithStar": () => (/* binding */ matchesWithStar)
/* harmony export */ });
function escapeRegExp(literal) {
    return literal.replace(/[^A-Za-z0-9_]/g, '\\$&');
}
function matchesWithStar(patternWithStar, input) {
    // Map "@types/*" --> "^\@types\/.*$"
    const pattern = '^' +
        patternWithStar
            .split('*')
            .map((x) => escapeRegExp(x))
            .join('.*') +
        '$';
    const regExp = new RegExp(pattern);
    return regExp.test(input);
}
//# sourceMappingURL=Utils.js.map

/***/ })

};
;
//# sourceMappingURL=DeployManager.js.map